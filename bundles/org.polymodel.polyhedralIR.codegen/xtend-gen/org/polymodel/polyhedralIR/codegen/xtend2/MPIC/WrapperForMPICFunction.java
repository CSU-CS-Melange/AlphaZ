package org.polymodel.polyhedralIR.codegen.xtend2.MPIC;

import com.google.common.collect.Iterables;
import org.eclipse.xtend2.lib.StringConcatenation;
import org.eclipse.xtext.xbase.lib.Functions.Function1;
import org.eclipse.xtext.xbase.lib.IterableExtensions;
import org.polymodel.polyhedralIR.codegen.xtend2.wrapperC.WrapperCFunction;
import org.polymodel.polyhedralIR.polyIRCG.Body;
import org.polymodel.polyhedralIR.polyIRCG.C.wrapper.InputInitialization;
import org.polymodel.polyhedralIR.polyIRCG.C.wrapper.OutputPrinting;
import org.polymodel.polyhedralIR.polyIRCG.C.wrapper.OutputVerification;
import org.polymodel.polyhedralIR.polyIRCG.CodeGenVariable;
import org.polymodel.polyhedralIR.polyIRCG.Function;
import org.polymodel.polyhedralIR.polyIRCG.generator.C.CodeGenConstantsForC;
import org.polymodel.polyhedralIR.polyIRCG.generator.C.CodeGenConstantsForDistributed;

@SuppressWarnings("all")
public class WrapperForMPICFunction extends WrapperCFunction {
  @Override
  public CharSequence code(final Function func) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("//function prototypes");
    _builder.newLine();
    CharSequence _mainFunctionPrototype = this.mainFunctionPrototype(func);
    _builder.append(_mainFunctionPrototype);
    _builder.newLineIfNotEmpty();
    _builder.newLine();
    _builder.append("//main");
    _builder.newLine();
    _builder.append("int main(int argc, char** argv) {");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("MPI_Init(&argc, &argv);");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("int ");
    _builder.append(CodeGenConstantsForDistributed.pid, "\t");
    _builder.append(";");
    _builder.newLineIfNotEmpty();
    _builder.append("\t");
    _builder.append("MPI_Comm_rank(MPI_COMM_WORLD,&");
    _builder.append(CodeGenConstantsForDistributed.pid, "\t");
    _builder.append(");");
    _builder.newLineIfNotEmpty();
    _builder.newLine();
    _builder.append("\t");
    CharSequence _checkNumberOfArgs = this.checkNumberOfArgs(func);
    _builder.append(_checkNumberOfArgs, "\t");
    _builder.newLineIfNotEmpty();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t");
    CharSequence _readParameters = this.readParameters(func);
    _builder.append(_readParameters, "\t");
    _builder.newLineIfNotEmpty();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t");
    CharSequence _parameterCheck = this.parameterCheck(func);
    _builder.append(_parameterCheck, "\t");
    _builder.newLineIfNotEmpty();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t");
    Object _tilingHandling = this.tilingHandling(func);
    _builder.append(_tilingHandling, "\t");
    _builder.newLineIfNotEmpty();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t");
    CharSequence _malloc = this.malloc(func);
    _builder.append(_malloc, "\t");
    _builder.newLineIfNotEmpty();
    _builder.newLine();
    _builder.append("\t");
    _builder.append("//Input Initialization");
    _builder.newLine();
    _builder.append("\t");
    final Function1<Body, Boolean> _function = (Body b) -> {
      return Boolean.valueOf((b instanceof InputInitialization));
    };
    final Function1<Body, CharSequence> _function_1 = (Body b) -> {
      return this.inputInitialization(((InputInitialization) b));
    };
    String _join = IterableExtensions.<Body>join(IterableExtensions.<Body>filter(func.getBodies(), _function), "", _function_1);
    _builder.append(_join, "\t");
    _builder.newLineIfNotEmpty();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("//Broadcast");
    _builder.newLine();
    {
      Iterable<CodeGenVariable> _filter = Iterables.<CodeGenVariable>filter(func.getInputs(), CodeGenVariable.class);
      for(final CodeGenVariable v : _filter) {
        _builder.append("\t");
        _builder.append("//broad case is not implemented right now");
        _builder.newLine();
      }
    }
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("//Timing");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("struct timeval time;");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("double elapsed_time;");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("//Call the main computation");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("gettimeofday(&time, NULL);");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("elapsed_time = (((double) time.tv_sec) + ((double) time.tv_usec)/1000000);");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t");
    CharSequence _mainFunctionCall = this.mainFunctionCall(func);
    _builder.append(_mainFunctionCall, "\t");
    _builder.newLineIfNotEmpty();
    _builder.newLine();
    _builder.append("\t");
    _builder.append("gettimeofday(&time, NULL);");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("elapsed_time = (((double) time.tv_sec) + ((double) time.tv_usec)/1000000) - elapsed_time;");
    _builder.newLine();
    _builder.newLine();
    _builder.append("\t");
    _builder.append("//output and verification is only done in a processor");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("if (pid == 0) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("// timing information");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("printf(\"Execution time : %lf sec.\\n\", elapsed_time);");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("//Verification Run");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("#ifdef ");
    _builder.append(CodeGenConstantsForC.VERIFY_FLAG, "\t\t");
    _builder.newLineIfNotEmpty();
    _builder.append("\t    \t");
    CharSequence _verifyFunctionCall = this.verifyFunctionCall(func);
    _builder.append(_verifyFunctionCall, "\t    \t");
    _builder.newLineIfNotEmpty();
    _builder.append("\t\t");
    _builder.append("#endif");
    _builder.newLine();
    _builder.append("\t    \t");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("#ifdef ");
    _builder.append(CodeGenConstantsForC.CHECKING_FLAG, "\t\t");
    _builder.newLineIfNotEmpty();
    _builder.append("\t    \t");
    _builder.append("//Print Outputs");
    _builder.newLine();
    _builder.append("\t\t\t");
    final Function1<Body, Boolean> _function_2 = (Body b) -> {
      return Boolean.valueOf((b instanceof OutputPrinting));
    };
    final Function1<Body, CharSequence> _function_3 = (Body b) -> {
      return this.printOutput(((OutputPrinting) b));
    };
    String _join_1 = IterableExtensions.<Body>join(IterableExtensions.<Body>filter(func.getBodies(), _function_2), "", _function_3);
    _builder.append(_join_1, "\t\t\t");
    _builder.newLineIfNotEmpty();
    _builder.append("\t\t");
    _builder.append("#elif ");
    _builder.append(CodeGenConstantsForC.VERIFY_FLAG, "\t\t");
    _builder.newLineIfNotEmpty();
    _builder.append("\t\t\t");
    _builder.append("//Compare outputs for verification");
    _builder.newLine();
    _builder.append("\t\t\t");
    final Function1<Body, Boolean> _function_4 = (Body b) -> {
      return Boolean.valueOf((b instanceof OutputVerification));
    };
    final Function1<Body, CharSequence> _function_5 = (Body b) -> {
      return this.verifyOutput(((OutputVerification) b));
    };
    String _join_2 = IterableExtensions.<Body>join(IterableExtensions.<Body>filter(func.getBodies(), _function_4), "", _function_5);
    _builder.append(_join_2, "\t\t\t");
    _builder.newLineIfNotEmpty();
    _builder.append("\t    ");
    _builder.append("#endif");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("}");
    _builder.newLine();
    _builder.append("    ");
    _builder.newLine();
    _builder.append("\t");
    CharSequence _mfree = this.mfree(func);
    _builder.append(_mfree, "\t");
    _builder.newLineIfNotEmpty();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("MPI_Finalize();");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    return _builder;
  }
}
