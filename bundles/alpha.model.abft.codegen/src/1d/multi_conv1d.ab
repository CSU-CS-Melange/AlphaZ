affine init { _P0,_N0,_K0,_PK0 | 0<_P0,_N0,_K0,_PK0 }
	input
		float kernel { i | -_K0<=i<=_K0 };
	output
		float padded_kernel { i | -_PK0<=i<=_PK0 };
		//double padded_kernel_cp { i | -_PK0<=i<=_PK0 };
		float patch { i | -_PK0<=i<_N0+_PK0};
		//double patch_cp { i | -_PK0<=i<_N0+_PK0};
	let
		padded_kernel[i] = case
			{|i<-_K0} : 0.0; 
			{|-_K0<=i<=_K0} : kernel[i];
			{|_K0<i} : 0.0;
		esac;
		
		patch[i] = case 
			{|i<0} : 0.0; 
			{|0<=i<_N0} : 1.0;
			{|_N0<=i} : 0.0;
		esac;
.

affine conv { _K0,_L0 | 0<_K0<=_L0 }
	input
		float kernel { i | -_K0<=i<=_K0 };
		float arr { i | 0<=i<_L0 };
	output
		float out { i | 0<=i<_L0 };
	let		
		out[i] = reduce(+, (i,p->i), {|0<=i+p<_L0} : arr[i+p] * kernel[-p]);
.