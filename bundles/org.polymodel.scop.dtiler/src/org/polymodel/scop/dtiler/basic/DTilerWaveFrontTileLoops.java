package org.polymodel.scop.dtiler.basic;

import static org.polymodel.algebra.factory.IntExpressionBuilder.affine;
import static org.polymodel.algebra.factory.IntExpressionBuilder.max;
import static org.polymodel.algebra.factory.IntExpressionBuilder.min;
import static org.polymodel.algebra.factory.IntExpressionBuilder.sum;
import static org.polymodel.algebra.factory.IntExpressionBuilder.symbolicDiv;
import static org.polymodel.algebra.factory.IntExpressionBuilder.term;
import static org.polymodel.algebra.factory.IntExpressionBuilder.var;

import java.util.ArrayList;
import java.util.Collections;
import java.util.LinkedList;
import java.util.List;
import java.util.Set;
import java.util.TreeSet;

import org.eclipse.emf.ecore.util.EcoreUtil;
import org.polymodel.algebra.ComparisonOperator;
import org.polymodel.algebra.IntConstraint;
import org.polymodel.algebra.IntConstraintSystem;
import org.polymodel.algebra.IntExpression;
import org.polymodel.algebra.factory.IntExpressionBuilder;
import org.polymodel.scop.AbstractScopNode;
import org.polymodel.scop.AbstractScopStatement;
import org.polymodel.scop.ScopBlock;
import org.polymodel.scop.ScopFor;
import org.polymodel.scop.ScopGuard;
import org.polymodel.scop.ScopUserFactory;
import org.polymodel.scop.annotation.ParallelLoopAnnotation;
import org.polymodel.scop.dtiler.AbstractTileLoopGenerator;
import org.polymodel.scop.dtiler.DTilingOptions;

/**
 * Generates tile loops for wave front parallel executing tile loops.  
 * 
 * @author antoine, yuki
 *
 */
public class DTilerWaveFrontTileLoops extends AbstractTileLoopGenerator {
	private List<String> specialPrivates = new LinkedList<String>();
	
	public DTilerWaveFrontTileLoops(DTilingOptions opt) {
		super(opt);
	}
	
	public DTilerWaveFrontTileLoops(DTilingOptions opt, List<String> _specialPrivates){
		super(opt);
		specialPrivates.addAll(_specialPrivates);
	}
	
	public void setSpecialPrivates(List<String> _specialPrivates){
		specialPrivates.addAll(_specialPrivates);
	}
	
	/**
	 * DTiling with WF. Input is a perfectly nested loop.
	 * 
	 * @param perfectly nested loops, input of DaeGon's algorithm
	 * @param options
	 * @return
	 */
	public TileLoop generate(ScopFor perfectNest, Set<String> untiledPointLoopIterators) {
		Set<String> privates = collectIteratorNames(perfectNest);
		for(String variable: specialPrivates){
			if(!privates.contains(variable)){
				privates.add(variable);
			}
		}
		
		privates.addAll(untiledPointLoopIterators);
		
		//Get tile loop
		TileLoop tileLoop = (new DTilerTileLoops(options)).generate(perfectNest);
		
		//loop generated by the default tile loop generator should be ScopFor
		ScopFor tiles = (ScopFor)tileLoop.start;
		
		//get list of loops int the tiled loops, the tiled loop is perfectly nested
		List<ScopFor> loops = extractLoops(tiles);
		
		List<AbstractScopNode> nodes = new LinkedList<AbstractScopNode>();
		
		//create start and end assignments
//				nodes.addAll(start(loops));
//				nodes.addAll(end(loops));
		/* There is bug if we use the previous methods to compute the start and 
		 * end. See the comment on the function wavefrontBounds for more details.
		 */
		nodes.addAll(wavefrontBounds(loops));
		
		//create time loop
		nodes.add(timeLoop(tileLoop));
		
		//add a guard of the innermost loop
		AbstractScopNode innermost = addGuardForInnerMostLoop(loops);
		
		//create a block since the tile loop now contains assignments
		ScopBlock block = ScopUserFactory.scopBlock(nodes);
		
		ParallelLoopAnnotation pla = ScopUserFactory.parallelLoopAnnotation(privates, "static", 1); 
		tileLoop.start.getScopAnnotations().add(pla);

		return new TileLoop(block, innermost);
	}
	
	/**
	 * DTiling with WF. Input is a perfectly nested loop.
	 * 
	 * @param perfectly nested loops, input of DaeGon's algorithm
	 * @param options
	 * @return
	 */
	public TileLoop generate(ScopFor perfectNest) {
		Set<String> privates = Collections.<String>emptySet();
		
		return generate(perfectNest, privates);
	}
	
	protected Set<String> collectIteratorNames(ScopFor perfectNest) {
		//collect list of loop iterators to be made private
		Set<String> privates = new TreeSet<String>();
		{
			ScopFor current = perfectNest;
			do {
				privates.add(options.getTileIndex(current.getLoopDepth()+options.tilingBand.getStart()).getName());
				privates.add(current.getIterator().getName());
				if (current.getBody() == null) break;
				if ((current.getBody() instanceof ScopFor)) {
					current = (ScopFor)current.getBody();
				} else if (current.getBody() instanceof ScopBlock) {
					ScopBlock block = (ScopBlock)current.getBody();
					if (block.getStatements().size() > 0 && block.getStatements().get(0) instanceof ScopFor) {
						current = (ScopFor)block.getStatements().get(0);
					} else {
						break;
					}
				} else {
					break;
				}
			} while (current != null);
		}
		
		return privates;
	}
	
	/**
	 * Creates a sequence of assignment statements to initialize the value of start
	 * Corresponds to line 1-4 in Figure 8.2 of DaeGon's Thesis.
	 * 
	 * @param loops
	 * @param options
	 * @return
	 */
	protected List<AbstractScopStatement> start(List<ScopFor> loops) {
		List<AbstractScopStatement> startStatements = new ArrayList<AbstractScopStatement>(loops.size()+1);

		List<IntExpression> expressions = new ArrayList<IntExpression>(loops.size());
		//for each dimension
		for (int k = 1; k <= loops.size(); k++) {
			//set ti_k to LB
			//create the statement with complete lower bound
//			IntExpression lbexp = null;
//			for(IScopAnnotation ann: loops.get(k-1).getScopAnnotations()){
//				if(ann instanceof TileLoopAnnotation){
//					lbexp = getLBExpression(EcoreUtil.copy(loops.get(k-1).getLB()), EcoreUtil.copy(((TileLoopAnnotation) ann).getBoxLB()));
//					break;
//				}
//			}
//			startStatements.add(ScopUserFactory.scopAssignment(options.getTileIndex(dim, level, permuted), EcoreUtil.copy(loops.get(k-1).getLB())));
			startStatements.add(ScopUserFactory.scopAssignment(options.getTileIndex(k), EcoreUtil.copy(loops.get(k-1).getLB())));
			
			//collect ti_k / ts_k
//			expressions.add(symbolicDiv(affine(term(options.getTileIndex(dim, level, permuted))),getTileSizeExpression(k)));
			expressions.add(symbolicDiv(affine(term(options.getTileIndex(k))),getTileSizeExpression(k)));
		}
		
//		int last_dim = loops.size() + start-1;
//		boolean last_permuted = options.permuted(last_dim, level);
//		startStatements.add(ScopUserFactory.scopAssignment(options.getWFInnerLoopOffset(), affine(term(options.getTileIndex(last_dim, level, last_permuted)))));
//		startStatements.add(ScopUserFactory.scopAssignment(options.getWFInnerLoopTileOffset(), EcoreUtil.copy(expressions.get(loops.size() - 1))));
		
		//start = sum(ti_k / ts_k)
		startStatements.add(ScopUserFactory.scopAssignment(options.getWFstart(), sum(expressions)));
		
		return startStatements;
	}

	/**
	 * Creates a sequence of assignment statements to initialize the value of 
	 * start and end of the time loop. 
	 * 
	 * The method mentioned in DaeGon's Thesis does not work for all the cases.
	 * i.e. 
	 * int C  {i,j | i+j>=N>=(i,j) };
	 *  C[i,j] = [i+j];
	 *  
	 * Then if we use identity schedule and generate parallel DTiled code with openmp
	 * and use 3 as input and 2,1 as the tile sizes. Then the tile 2,0 will not get 
	 * executed. Because the time_start = time(0,2) = 0/2+2/1 = 2 and 
	 * time_end = time(2,3) = 2/2+3/1 = 4
	 * Therefore, wavefronts goes from [2,4]. But the time(2,0) = 2/2+0/1 = 1
	 * which means the time stamp of tile(2,0) = 1 and it will not be visited by 
	 * the time loop.
	 *
	 * To solve this issue, we compute the start and end of the time stamp by 
	 * considering all the corners(or vertices) of the tile lattice  
	 * 
	 *  
	 * @param loops 
	 * @return List<AbstractScopStatement> list of statements to compute start and end of time loop
	 */
	protected List<AbstractScopStatement> wavefrontBounds(List<ScopFor> loops) {
		// For each corner in the polyhedron, we create a timestamp expression 
		// and take the min of all of to figure out the start and the max for end
		int numExps = (int) Math.pow(2, loops.size()); //number of corners
		
		List<AbstractScopStatement> startStatements = 
				new ArrayList<AbstractScopStatement>((loops.size()+2)*numExps+2);
		List<IntExpression> expressions = new ArrayList<IntExpression>(loops.size());
		
		startStatements.add(ScopUserFactory.scopAssignment(
				options.getWFstart(), affine(var("INT_MAX"))));
		startStatements.add(ScopUserFactory.scopAssignment(
				options.getWFend(), affine(var("INT_MIN"))));
		
		for (int k = 0; k < numExps; k++) {
			expressions = new ArrayList<IntExpression>(loops.size());
			for (int d=0; d<loops.size(); d++) {
				int bit = (k >> loops.size()-d-1) & 1;
				int previousBit = k>0 ? (k-1 >> loops.size()-d-1) & 1 : -1;
				if (previousBit != bit) { 
					startStatements.add(ScopUserFactory.scopAssignment(
							options.getTileIndex(d+1+options.tilingBand.getStart()), 
							bit==0 ? EcoreUtil.copy(loops.get(d).getLB())
								   : EcoreUtil.copy(loops.get(d).getUB())));
				}
				expressions.add(symbolicDiv(
						affine(term(options.getTileIndex(d+1+options.tilingBand.getStart()))),
						getTileSizeExpression(d+1+options.tilingBand.getStart())));
			}
			
			IntExpression sum = sum(expressions);
			startStatements.add(ScopUserFactory.scopAssignment(options.getWFstart(), 
					min(affine(term(options.getWFstart())),sum)));
			startStatements.add(ScopUserFactory.scopAssignment(options.getWFend(), 
					max(affine(term(options.getWFend())),sum.copy())));
		}
		
		return startStatements;
	}
	
	/**
	 * Creates a sequence of assignment statements to initialize the value of end
	 * Corresponds to line 5-8 in Figure 8.2 of DaeGon's Thesis.
	 * 
	 * @param loops
	 * @param options
	 * @return
	 */
	protected List<AbstractScopStatement> end(List<ScopFor> loops) {
		List<AbstractScopStatement> endStatements = new ArrayList<AbstractScopStatement>(loops.size()+1);


		List<IntExpression> expressions = new ArrayList<IntExpression>(loops.size());
		for (int k = 1; k <= loops.size(); k++) {
			//set ti_k to UB
			
//			IntExpression ubexp = null;
//			for(IScopAnnotation ann: loops.get(k-1).getScopAnnotations()){
//				if(ann instanceof TileLoopAnnotation){
//					ubexp = getUBExpression(EcoreUtil.copy(loops.get(k-1).getUB()), EcoreUtil.copy(((TileLoopAnnotation) ann).getBoxUB()));
//					break;
//				}
//			}
//			endStatements.add(ScopUserFactory.scopAssignment(options.getTileIndex(dim, level, permuted), EcoreUtil.copy(loops.get(k-1).getUB())));
			endStatements.add(ScopUserFactory.scopAssignment(options.getTileIndex(k), EcoreUtil.copy(loops.get(k-1).getUB())));

			//collect ti_k / ts_k
//			expressions.add(symbolicDiv(affine(term(options.getTileIndex(dim, level, permuted))), getTileSizeExpression(k)));
			expressions.add(symbolicDiv(affine(term(options.getTileIndex(k))), getTileSizeExpression(k)));
		}

		
		//end = sum(ti_k / ts_k)
		endStatements.add(ScopUserFactory.scopAssignment(options.getWFend(), sum(expressions)));
			
		return endStatements;
	}
	
	/**
	 * Creates a time loop using time/start/end variables that surrounds the tile loops.
	 * Corresponds to line 9-12 in Figure 8.2 of DaeGon's Thesis.
	 * (except that the last tile loop is already there)
	 * 
	 * @param tileLoop
	 * @param options
	 * @return
	 */
	protected ScopFor timeLoop(TileLoop tileLoop) {
		IntExpression startExp = affine(term(options.getWFstart()));
		IntExpression endExp   = affine(term(options.getWFend()));
		//add the start of the tile loop as the body of the tile loop
		List<AbstractScopNode> body = new ArrayList<AbstractScopNode>(1);
		body.add(tileLoop.start);
		
		return ScopUserFactory.scopFor(options.getWFtime(), startExp, endExp, affine(term(1)), ScopUserFactory.scopBlock(body));
	}
	
	/**
	 * Creates an expression to assign the innermost tile index.
	 * This implementation assumes 45 degree (in all dimensions) wave-front schedule
	 * 
	 * @param loops
	 * @return
	 */
	protected IntExpression getInnermostTidAssignmentExpression(List<ScopFor> loops) {
		//create an assignment to ti_d
		List<IntExpression> expressions = new ArrayList<IntExpression>(loops.size());
		//for each d, collect ti_k / ts_k (excluding the last loop)
		for (int k = 1; k < loops.size(); k++) {
			expressions.add(symbolicDiv(affine(term(options.getTileIndex(k+options.tilingBand.getStart()))), getTileSizeExpression(k+options.tilingBand.getStart())));
		}
		//expressions.add(affine(term(options.getWFInnerLoopTileOffset())));
		
		//rhs = (time - sum(ti_k / ts_k)) * ts_d
		return IntExpressionBuilder.prod(IntExpressionBuilder.sub(affine(term(options.getWFtime())), sum(expressions)), getTileSizeExpression(loops.size()+options.tilingBand.getStart()));
		//IntExpression exp = IntExpressionBuilder.prod(IntExpressionBuilder.sub(affine(term(options.getWFtime())), sum(expressions)), getTileSizeExpression(loops.size()));
		//RHS = (time - sum(ti_k / ts_k) - tile_start) * ts_d + lb
		//return IntExpressionBuilder.sum(affine(term(options.getWFInnerLoopOffset())), exp);

	}
	
	/**
	 * Creates a guard in the inner most tile loop.
	 * Corresponds to line 13-14 in Figure 8.2 of DaeGon's Thesis.
	 * 
	 * @param loops
	 * @param options
	 * @return
	 */
	protected AbstractScopNode addGuardForInnerMostLoop(List<ScopFor> loops) {
		//modify the last loop of the tile loop
		ScopFor lastLoop = loops.get(loops.size()-1);

		AbstractScopStatement assignTId = ScopUserFactory.scopAssignment(lastLoop.getIterator(), getInnermostTidAssignmentExpression(loops));
		
//		IntExpression lbexp = null;
//		IntExpression ubexp = null;
//		for(IScopAnnotation ann: lastLoop.getScopAnnotations()){
//			if(ann instanceof TileLoopAnnotation){
//				lbexp = getLBExpression(EcoreUtil.copy(lastLoop.getLB()), EcoreUtil.copy(((TileLoopAnnotation) ann).getBoxLB()));
//				ubexp = getUBExpression(EcoreUtil.copy(lastLoop.getUB()), EcoreUtil.copy(((TileLoopAnnotation) ann).getBoxUB()));
//				break;
//			}
//		}
		//Create a guard with two constraints
		//lb_d <= ti_d <= ub_d
		IntConstraint lbc = IntExpressionBuilder.constraint(EcoreUtil.copy(lastLoop.getLB()), affine(term(lastLoop.getIterator())), ComparisonOperator.LE);
		IntConstraint ubc = IntExpressionBuilder.constraint(affine(term(lastLoop.getIterator())), EcoreUtil.copy(lastLoop.getUB()), ComparisonOperator.LE);
//		IntConstraint lbc = IntExpressionBuilder.constraint(lbexp, affine(term(lastLoop.getIterator())), ComparisonOperator.LE);
//		IntConstraint ubc = IntExpressionBuilder.constraint(affine(term(lastLoop.getIterator())), ubexp, ComparisonOperator.LE);
		
		
		List<IntConstraintSystem> cnstList = new ArrayList<IntConstraintSystem>(1);
		cnstList.add(IntExpressionBuilder.constraintSystem(lbc, ubc));
		
		//inside the guard is the body of the last loop
		// get the parent loop beforehand to avoid containment issues
		ScopFor beforeLast = lastLoop.getSurroundingScopFor();

		ScopGuard llguard = ScopUserFactory.scopGuard(cnstList, lastLoop.getBody(), null);
		
		//add the assignment and guard to the parent
		final ScopBlock block;
		if (beforeLast.getBody() instanceof ScopBlock) {
			block = (ScopBlock)beforeLast.getBody();
		} else {
			block = ScopUserFactory.scopBlock(new LinkedList<AbstractScopNode>());
			block.getStatements().add(beforeLast.getBody());
			beforeLast.setBody(block);
		}
		block.getStatements().add(assignTId);
		block.getStatements().add(llguard);
		//last loop is removed
		EcoreUtil.remove(lastLoop);
		
		return llguard;
	}
	
	/**
	 * Extracts a list of loops (from outer to inner) that are contained by the given LoopNest.
	 * Assumes that the given loop nest is a single loop perfectly nested loop nest without any statements.
	 * 
	 * @param loopNest
	 * @return
	 */
	public static List<ScopFor> extractLoops(ScopFor loopNest) {

		//get list of loops
		List<ScopFor> loops = new LinkedList<ScopFor>();
		loops.add(loopNest);
		{
			ScopFor loop = loopNest;
			while (true) {
				if (!(loop.getBody() != null && (loop.getBody() instanceof ScopFor || loop.getBody() instanceof ScopBlock))) {
					break;
				}
				if (loop.getBody() instanceof ScopBlock) {
					if(((ScopBlock)loop.getBody()).getStatements().get(0) instanceof ScopFor){
						loop = (ScopFor)((ScopBlock)loop.getBody()).getStatements().get(0);
					}else{
						break;
					}
				} else {
					loop = (ScopFor)loop.getBody();
				}
				loops.add(loop);
			}
		}
		
		return loops;
	}
	
	protected IntExpression getTileSizeExpression(int dim) {
		return affine(options.getTileSize(dim));
	}
	
	protected IntExpression getLBExpression(IntExpression lb, IntExpression Boxlb){
		if(Boxlb != null){
			return max(lb, Boxlb);
		}else{
			return lb;
		}
	}
	
	protected IntExpression getUBExpression(IntExpression ub, IntExpression Boxub){
		if(Boxub != null){
			return min(ub, Boxub);
		}else{
			return ub;
		}
	}
}
