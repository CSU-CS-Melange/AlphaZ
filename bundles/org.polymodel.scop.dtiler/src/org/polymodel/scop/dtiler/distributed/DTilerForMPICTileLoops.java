package org.polymodel.scop.dtiler.distributed;

import static org.polymodel.algebra.factory.IntExpressionBuilder.affine;
import static org.polymodel.algebra.factory.IntExpressionBuilder.sum;
import static org.polymodel.algebra.factory.IntExpressionBuilder.symbolicDiv;
import static org.polymodel.algebra.factory.IntExpressionBuilder.term;

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Set;

import org.eclipse.emf.ecore.util.EcoreUtil;
import org.polymodel.algebra.IntExpression;
import org.polymodel.algebra.factory.IntExpressionBuilder;
import org.polymodel.scop.AbstractScopNode;
import org.polymodel.scop.AbstractScopStatement;
import org.polymodel.scop.ScopAssignment;
import org.polymodel.scop.ScopBlock;
import org.polymodel.scop.ScopFor;
import org.polymodel.scop.ScopGuard;
import org.polymodel.scop.ScopStatementMacro;
import org.polymodel.scop.ScopUserFactory;
import org.polymodel.scop.dtiler.DTilingOptions;
import org.polymodel.scop.dtiler.basic.DTilerTileLoops;
import org.polymodel.scop.dtiler.basic.DTilerWaveFrontTileLoops;
import org.polymodel.scop.dtiler.basic.TileLoop;

public class DTilerForMPICTileLoops extends DTilerWaveFrontTileLoops {
	
	public DTilerForMPICTileLoops(DTilingOptions options) {
		super(options);
	}
	
	public TileLoop generate(ScopFor perfectNest) {
		Set<String> privates = collectIteratorNames(perfectNest);
		//also add start/end/time
//		privates.add(options.getWFstart().getName());
//		privates.add(options.getWFend().getName());
//		privates.add(options.getWFtime().getName());
		
		//Get tile loop
		TileLoop tileLoop = (new DTilerTileLoops(options)).generate(perfectNest);
		
		//loop generated by the default tile loop generator should be ScopFor
		ScopFor tiles = (ScopFor)tileLoop.start;
		
		//get list of loops
		List<ScopFor> loops = extractLoops(tiles);
		
		List<AbstractScopNode> nodes = new LinkedList<AbstractScopNode>();
		////since library calls cannot be expressed as IntExpressions, define it as macro, and use the inline feature of code gen later
		//nodes.add(ScopUserFactory.scopStatementMacro(options.forDist.PIDInitMacroName, new LinkedList<IntExpression>()));
//		privates.add(options.forDist.getPID().getName());
//		privates.add(options.forDist.getPartitioningChunkID().getName());
//		privates.add(options.forDist.getPartitioningChunkMemoryID().getName());
		
		//create start and end assignments
		nodes.addAll(start(loops));
		nodes.addAll(end(loops));
		
		//add calls to getTileID
		addCallsToGetTileID(tileLoop);
		
		//create time loop
		ScopFor timeLoop = timeLoop(tileLoop);
		nodes.add(timeLoop);
		
		//add a guard of the innermost loop
		AbstractScopNode innermost = addGuardForInnerMostLoop(loops);
		
		//partition the outermost tile loop
		addLoopsForPartitioning(tileLoop, privates);
		privates.add(options.forDist.getChunkOrigin().getName());
		
		//create a block since the tile loop now contains assignments
		ScopBlock block = ScopUserFactory.scopBlock(nodes);
//		TiledBlock tiled = new TiledBlock(block, perfectNest, SimplifyNestedBlocks.simplify(tileloop.start), points);
		
		return new TileLoop(block, innermost);
	}
	

	/**
	 * Creates a sequence of assignment statements to initialize the value of start
	 * Corresponds to line 1-4 in Figure 8.2 of DaeGon's Thesis.
	 * 
	 * @param loops
	 * @param options
	 * @return
	 */
	protected List<AbstractScopStatement> start(List<ScopFor> loops) {
		List<AbstractScopStatement> startStatements = super.start(loops);

//		IntExpression ti1LB = loops.get(0).getLB().copy();
		
		//tileLB = ti_1+ts1-1
//		startStatements.add(ScopUserFactory.scopAssignment(options.getOuterTilesLB(), sum(ti1LB, affine(options.getTileSize(1)), constant(-1))));
		
		return startStatements;
	}

	/**
	 * Creates a sequence of assignment statements to initialize the value of end
	 * Corresponds to line 5-8 in Figure 8.2 of DaeGon's Thesis.
	 * 
	 * @param loops
	 * @param options
	 * @return
	 */
	protected List<AbstractScopStatement> end(List<ScopFor> loops) {
		List<AbstractScopStatement> endStatements = super.end(loops);

//		IntExpression ti1UB = loops.get(0).getUB().copy();
		
		//tileUB = ti_1-ts1+1
//		endStatements.add(ScopUserFactory.scopAssignment(options.getOuterTilesUB(), sum(ti1UB, affine(term(-1, options.getTileSize(1).getVariable())), constant(1))));
		
		return endStatements;
	}
	
	protected void addCallsToGetTileID(TileLoop tileLoop) {
//		List<ScopFor> loops = tileLoop.innerMost.getSurroundingScopFors();
//		for (int i = 0; i < loops.size(); i++) {
//			//add initialization of tile ID
//			ScopBlock block = ScopUserFactory.scopBlock(new ArrayList<AbstractScopNode>(0));
//			block.getStatements().add(ScopUserFactory.scopStatementMacro(options.forPGAS.getTileMIDMacroName(i+1), new ArrayList<IntExpression>(0)));
//			block.getStatements().add(loops.get(i).getBody());
//			loops.get(i).setBody(block);
//		}
	}
	
	@Override
	protected ScopFor timeLoop(TileLoop tileLoop) {
		ScopFor timeLoop = super.timeLoop(tileLoop);
		
		//add initialization of chunkMID (to -1) 
		ScopAssignment sa = ScopUserFactory.scopAssignment(options.forDist.getPartitioningChunkMemoryID(), IntExpressionBuilder.constant(-1));
		((ScopBlock)timeLoop.getBody()).getStatements().add(0, sa);
		
		return timeLoop;
	}
	
	/**
	 * Create a new loop and modify the fist tile loop so that different subsets of the first tile loop is visited by each processor. 
	 * 
	 * @param tileLoop
	 */
	protected void addLoopsForPartitioning(TileLoop tileLoop, Set<String> privates) {
		ScopFor firstTileLoop = (ScopFor)tileLoop.start;
		
		ScopBlock ploopBlock = ScopUserFactory.scopBlock(new ArrayList<AbstractScopNode>());
		ScopFor ploop = ScopUserFactory.scopFor(options.forDist.getChunkOrigin(), firstTileLoop.getLB().copy(), firstTileLoop.getUB().copy(), 
				affine(options.getTileSize(1)), ploopBlock);
		
		//add tiled annotation so that up transformation (up(t,s) = ceild(t,s)*s) is applied
		ploop.getScopAnnotations().add(ScopUserFactory.tileLoopAnnotation(options.getTileIndex(1), affine(options.getTileSize(1))));
		
		//actually, no barrier is needed since Send/Recv does it between the two processors
//		//this loop also needs a barrier after completing
//		ploop.getScopAnnotations().add(ScopUserFactory.barrierAnnotation(false, 1));
		
		ploop.getScopAnnotations().add(ScopUserFactory.description(options.forDist.chunkOrigin+" is the start of a chunk for each processor"));
		
		//add offset to the start of the partitioning loop. offset = coef*pid*ts1 
		IntExpression offset = IntExpressionBuilder.prod(
								affine(term(options.forDist.getChunkSize())),
								affine(term(options.forDist.getPID())));
		ploop.setLB(IntExpressionBuilder.sum(ploop.getLB(), offset));
		
		//change the stride to skip other processors range
		IntExpression stride = IntExpressionBuilder.prod(
									affine(term(options.forDist.getChunkSize())),
									affine(term(options.forDist.getPCount())));
		ploop.setStride(stride);
		
		EcoreUtil.replace(firstTileLoop, ploop);
		
//		add 1 to chunkMID each iteration
		//add initialization of chunkMID (to -1) 
		ScopAssignment midIncrement = ScopUserFactory.scopAssignment(options.forDist.getPartitioningChunkMemoryID(), affine(term(options.forDist.getPartitioningChunkMemoryID()), term(1)));
		ploopBlock.getStatements().add(midIncrement);
		
		ploopBlock.getStatements().add(firstTileLoop);
		
		//modify the first tile loop so that partitioned block is visited
		firstTileLoop.getScopAnnotations().clear();//remove tile loop annotation
		//firstTileLoop.getScopAnnotations().add(ScopUserFactory.parallelLoopAnnotation(privates)); FIXME
		//ti1 = pstart; ti1 < pstart+poffsetCoef*ts1; ti1+=ts1
		firstTileLoop.setLB(affine(term(options.forDist.getChunkOrigin())));
		firstTileLoop.setStride(affine(options.getTileSize(1)));
		IntExpression UB = IntExpressionBuilder.sum(
								affine(term(options.forDist.getChunkOrigin())),
										affine(term(options.forDist.getChunkSize())
									),
								affine(term(-1))
							);
		//take the min with the original UB
		firstTileLoop.setUB(IntExpressionBuilder.min(UB, firstTileLoop.getUB()));
		
	}
	
	@Override
	protected AbstractScopNode addGuardForInnerMostLoop(List<ScopFor> loops) {
		ScopGuard llguard = (ScopGuard)super.addGuardForInnerMostLoop(loops);
		
		//add macros for the send code
		ScopStatementMacro send = ScopUserFactory.scopStatementMacro(options.forDist.sendFunctionName, new ArrayList<IntExpression>());
		
		//at this point, point loops is just a place holder, since its generated elsewhere, so just create a new block
		ScopBlock points = ScopUserFactory.scopBlock(new ArrayList<AbstractScopNode>());
		ScopBlock thenBlock = ScopUserFactory.scopBlock(new ArrayList<AbstractScopNode>());

		//insert the send code after the point loop
		thenBlock.getStatements().add(points);
		thenBlock.getStatements().add(send);
		
		llguard.setThenBody(thenBlock);
		
		//recv code is placed outside of the guard
		ScopStatementMacro recvStart  = ScopUserFactory.scopStatementMacro(options.forDist.recvStartFunctionName, new ArrayList<IntExpression>());
		ScopStatementMacro recvEnd = ScopUserFactory.scopStatementMacro(options.forDist.recvEndFunctionName, new ArrayList<IntExpression>());
		
		//get the last loop (d-1th)
		ScopFor lloop = llguard.getSurroundingScopFor();
		//its body should be a block
		assert(lloop.getBody() instanceof ScopBlock);
		
		ScopBlock lblock = (ScopBlock)lloop.getBody();
		//and it should have tid assignment and the guard as its body
		assert(lblock.getStatements().size() == 2);

		//insert Irecv and Iwait before and after the guard
		lblock.getStatements().add(1, recvStart);
		lblock.getStatements().add(recvEnd);
		
//		//add tidNext computation (tid with time+1)
//		lblock.getStatements().add(1, getTIDNext(loops));

		//pointer to the point loop is the output of this method
		return points;
	}
	
	protected IntExpression getChunkSizeExpression() {
		return affine(term(options.forDist.getChunkSize()));
	}
	
	@Override
	protected IntExpression getTileSizeExpression(int dim) {
//		return super.getTileSizeExpression(dim);
		if (dim > 1) {
			return super.getTileSizeExpression(dim);
		//t1 is multiplied by numTilesPerChunk
		} else {
			return affine(term(options.forDist.getChunkSize()));
		}
	}
	
	@Override
	protected IntExpression getInnermostTidAssignmentExpression(List<ScopFor> loops) {
//		//for this expression, chunkSize should be replaced back with ti1
//		IntExpression expr = super.getInnermostTidAssignmentExpression(loops).simplify();
//		return expr.substitute(options.forDist.getChunkSize(), options.getTileIndex(1));
		
		//since substitute do not work for polynomials yet, used in symbolic divisions, mostly copied code below

		List<IntExpression> expressions = new ArrayList<IntExpression>(loops.size());
		//for each d, collect ti_k / ts_k (excluding the last loop)
		for (int k = 1; k < loops.size(); k++) {
			IntExpression  ts = super.getTileSizeExpression(k);
			expressions.add(symbolicDiv(affine(term(options.getTileIndex(k))), ts));
		}
		
		//rhs = (time - sum(ti_k / ts_k)) * ts_d
		return IntExpressionBuilder.prod(IntExpressionBuilder.sub(affine(term(options.getWFtime())), sum(expressions)), getTileSizeExpression(loops.size()));
	}
	
//	protected ScopAssignment getTIDNext(List<ScopFor> loops) {
//		List<IntExpression> expressions = new ArrayList<IntExpression>(loops.size());
//		//for each d, collect ti_k / ts_k (excluding the last loop)
//		for (int k = 1; k < loops.size(); k++) {
//			IntExpression  ts = super.getTileSizeExpression(k);
//			expressions.add(symbolicDiv(affine(term(options.getTileIndex(k))), ts));
//		}
//		
//		IntExpression tidNext = IntExpressionBuilder.prod(IntExpressionBuilder.sub(affine(term(options.getWFtime()), term(1)), sum(expressions)), getTileSizeExpression(loops.size()));
//		
//		return ScopUserFactory.scopAssignment(options.forDist.getNextTileIndex(loops.size()), tidNext);
//	}
}
