package org.polymodel.scop;

/* PROTECTED REGION ID(scop_user_factory_imports) ENABLED START */
// protected imports, you should add here required imports
// that won't be removed after regeneration of the mapping code
import java.util.Arrays;
/* PROTECTED REGION END */
import java.util.Collection;
import java.util.List;

import org.polymodel.algebra.IntConstraintSystem;
import org.polymodel.algebra.IntExpression;
import org.polymodel.algebra.Variable;
import org.polymodel.scop.annotation.AnnotationFactory;
import org.polymodel.scop.annotation.BarrierAnnotation;
import org.polymodel.scop.annotation.DescriptionAnnotation;
import org.polymodel.scop.annotation.ParallelBlockAnnotation;
import org.polymodel.scop.annotation.ParallelLoopAnnotation;
import org.polymodel.scop.annotation.PolyhedralDomainAnnotation;
import org.polymodel.scop.annotation.SingleAnnotation;
import org.polymodel.scop.annotation.TileLoopAnnotation;
import org.polymodel.scop.annotation.VectorizationAnnotation;

import fr.irisa.cairn.jnimap.isl.jni.JNIISLUnionMap;

/**
* User factory for scop
* -- Generated by TOM mapping EMF generator --
*/

public class ScopUserFactory {
	
	/* PROTECTED REGION ID(scop_user_factory_members) ENABLED START */
	/* PROTECTED REGION END */

	// packageListBis
	public static ScopFactory scopFactory = ScopFactory.eINSTANCE;
	
	// User operators
		
	/** Module nodes **/
	// Operator root
	public static ScopRoot root(List<AbstractScopNode> _statements) {
		ScopRoot o = scopFactory.createScopRoot();
		for(int i = 0 ; i < _statements.size() ; ++i) {
			o.getStatements().add(_statements.get(i));
		}
		
		/* PROTECTED REGION ID(scop_user_factory_class_op_root) ENABLED START */
		/* PROTECTED REGION END */
		
		return o;
	}
		
	// Operator loop
	public static ScopFor loop(Variable _iterator, IntExpression _LB, IntExpression _UB, IntExpression _stride, AbstractScopNode _body) {
		ScopFor o = scopFactory.createScopFor();
		o.setIterator(_iterator);
		o.setLB(_LB);
		o.setUB(_UB);
		o.setStride(_stride);
		o.setBody(_body);
		
		/* PROTECTED REGION ID(scop_user_factory_class_op_loop) ENABLED START */
		/* PROTECTED REGION END */
		
		return o;
	}
		
	// Operator block
	public static ScopBlock block(List<AbstractScopNode> _statements) {
		ScopBlock o = scopFactory.createScopBlock();
		for(int i = 0 ; i < _statements.size() ; ++i) {
			o.getStatements().add(_statements.get(i));
		}
		
		/* PROTECTED REGION ID(scop_user_factory_class_op_block) ENABLED START */
		/* PROTECTED REGION END */
		
		return o;
	}
		
	// Operator guard
	public static ScopGuard guard(List<IntConstraintSystem> _constraintSystems, AbstractScopNode _thenBody, AbstractScopNode _elseBody) {
		ScopGuard o = scopFactory.createScopGuard();
		for(int i = 0 ; i < _constraintSystems.size() ; ++i) {
			o.getConstraintSystems().add(_constraintSystems.get(i));
		}
		o.setThenBody(_thenBody);
		o.setElseBody(_elseBody);
		
		/* PROTECTED REGION ID(scop_user_factory_class_op_guard) ENABLED START */
		/* PROTECTED REGION END */
		
		return o;
	}
		
	// Operator guardNoElse
	public static ScopGuard guardNoElse(List<IntConstraintSystem> _constraintSystems, AbstractScopNode _thenBody) {
		ScopGuard o = scopFactory.createScopGuard();
		for(int i = 0 ; i < _constraintSystems.size() ; ++i) {
			o.getConstraintSystems().add(_constraintSystems.get(i));
		}
		o.setThenBody(_thenBody);
		
		/* PROTECTED REGION ID(scop_user_factory_class_op_guardNoElse) ENABLED START */
		/* PROTECTED REGION END */
		
		return o;
	}
		
	// Operator stmtMacro
	public static ScopStatementMacro stmtMacro(String _name, List<IntExpression> _macroParams) {
		ScopStatementMacro o = scopFactory.createScopStatementMacro();
		o.setName(_name);
		for(int i = 0 ; i < _macroParams.size() ; ++i) {
			o.getMacroParams().add(_macroParams.get(i));
		}
		
		/* PROTECTED REGION ID(scop_user_factory_class_op_stmtMacro) ENABLED START */
		/* PROTECTED REGION END */
		
		return o;
	}
		
	// Operator assignment
	public static ScopAssignment assignment(Variable _LHS, IntExpression _RHS) {
		ScopAssignment o = scopFactory.createScopAssignment();
		o.setLHS(_LHS);
		o.setRHS(_RHS);
		
		/* PROTECTED REGION ID(scop_user_factory_class_op_assignment) ENABLED START */
		/* PROTECTED REGION END */
		
		return o;
	}
		
	
	/*
	* Default TOM Operators for scop mapping. Each class that has a terminal type has also a default factory function.
	*/
	
	public static ScopRoot scopRoot(List<AbstractScopNode> _statements) {
		ScopRoot o = scopFactory.createScopRoot();
		for(int i = 0 ; i < _statements.size() ; ++i) {
			o.getStatements().add(_statements.get(i));
		}
		
		/* PROTECTED REGION ID(scop_user_factory_default_op_ScopRoot) ENABLED START */
		/* PROTECTED REGION END */
		
		return o;
	}
	
	public static ScopFor scopFor(Variable _iterator, IntExpression _LB, IntExpression _UB, IntExpression _stride, AbstractScopNode _body) {
		ScopFor o = scopFactory.createScopFor();
		o.setIterator(_iterator);
		o.setLB(_LB);
		o.setUB(_UB);
		o.setStride(_stride);
		o.setBody(_body);
		
		/* PROTECTED REGION ID(scop_user_factory_default_op_ScopFor) ENABLED START */
		/* PROTECTED REGION END */
		
		return o;
	}
	
	public static ScopBlock scopBlock(List<AbstractScopNode> _statements) {
		ScopBlock o = scopFactory.createScopBlock();
		for(int i = 0 ; i < _statements.size() ; ++i) {
			o.getStatements().add(_statements.get(i));
		}
		
		/* PROTECTED REGION ID(scop_user_factory_default_op_ScopBlock) ENABLED START */
		/* PROTECTED REGION END */
		
		return o;
	}
	
	public static ScopGuard scopGuard(List<IntConstraintSystem> _constraintSystems, AbstractScopNode _thenBody, AbstractScopNode _elseBody) {
		ScopGuard o = scopFactory.createScopGuard();
		for(int i = 0 ; i < _constraintSystems.size() ; ++i) {
			o.getConstraintSystems().add(_constraintSystems.get(i));
		}
		o.setThenBody(_thenBody);
		o.setElseBody(_elseBody);
		
		/* PROTECTED REGION ID(scop_user_factory_default_op_ScopGuard) ENABLED START */
		/* PROTECTED REGION END */
		
		return o;
	}
	
	public static ScopStatementMacro scopStatementMacro(String _name,List<IntExpression> _macroParams) {
		ScopStatementMacro o = scopFactory.createScopStatementMacro();
		o.setName(_name);
		for(int i = 0 ; i < _macroParams.size() ; ++i) {
			o.getMacroParams().add(_macroParams.get(i));
		}
		
		/* PROTECTED REGION ID(scop_user_factory_default_op_ScopStatementMacro) ENABLED START */
		/* PROTECTED REGION END */
		
		return o;
	}
	
	public static ScopUnscannedDomain scopUnscannedDomain(String _name,List<IntExpression> _macroParams,JNIISLUnionMap _schedule) {
		ScopUnscannedDomain o = scopFactory.createScopUnscannedDomain();
		o.setName(_name);
		for(int i = 0 ; i < _macroParams.size() ; ++i) {
			o.getMacroParams().add(_macroParams.get(i));
		}
		o.setSchedule(_schedule);
		
		/* PROTECTED REGION ID(scop_user_factory_default_op_ScopStatementMacro) ENABLED START */
		/* PROTECTED REGION END */
		
		return o;
	}
	
	
	public static ScopAssignment scopAssignment(Variable _LHS, IntExpression _RHS) {
		ScopAssignment o = scopFactory.createScopAssignment();
		o.setLHS(_LHS);
		o.setRHS(_RHS);
		
		/* PROTECTED REGION ID(scop_user_factory_default_op_ScopAssignment) ENABLED START */
		/* PROTECTED REGION END */
		
		return o;
	}
	
	
	/* PROTECTED REGION ID(scop_mapping_user_custom_methodsscop) ENABLED START */
	
	/*
	* Custom factory functions that won't be removed at regeneration of mapping code
	*/
	public static ScopRoot scopRoot(AbstractScopNode... _statements) {
		return scopRoot(Arrays.asList(_statements));
	}
	public static ScopBlock scopBlock(AbstractScopNode... _statements) {
		return scopBlock(Arrays.asList(_statements));
	}
	public static ScopBlock scopBlock() {
		ScopBlock o = scopFactory.createScopBlock();
		return o;
	}
	
	
	/**
	 * Creates a tile loop annotation, work around until symbolic ceildiv is supported by IntExpression
	 * 
	 */
	public static TileLoopAnnotation tileLoopAnnotation(Variable tileIndex, IntExpression tileSize) {
		return tileLoopAnnotation(tileIndex, tileSize, null);
	}
	
	public static TileLoopAnnotation tileLoopAnnotation(Variable tileIndex, IntExpression tileSize, IntExpression offset) {
		TileLoopAnnotation tla = AnnotationFactory.eINSTANCE.createTileLoopAnnotation();
		tla.setTileIndex(tileIndex);
		tla.setTileSize(tileSize);
		tla.setOffset(offset);
		return tla;
	}
	
	public static DescriptionAnnotation description(String desc) {
		DescriptionAnnotation da = AnnotationFactory.eINSTANCE.createDescriptionAnnotation();
		da.setDescription(desc);
		return da;
	}
	
	/////////////Function for create scop annotations
	public static ParallelLoopAnnotation parallelLoopAnnotation(Collection<String> privates) {
		return parallelLoopAnnotation(privates, null, -1);
	}
	
	public static ParallelLoopAnnotation parallelLoopAnnotation(Collection<String> privates, String schedule){
		
		return parallelLoopAnnotation(privates, schedule, -1);
	}
	
	public static ParallelLoopAnnotation parallelLoopAnnotation(Collection<String> privates, String schedule, int chunksize){
		ParallelLoopAnnotation pla = AnnotationFactory.eINSTANCE.createParallelLoopAnnotation();
		
		pla.getPrivates().addAll(privates);
		pla.setSchedule(schedule);
		pla.setChunksize(chunksize);
		
		return pla;
	}
	
	public static SingleAnnotation singleAnnotation() {
		return AnnotationFactory.eINSTANCE.createSingleAnnotation();
	}

	public static ParallelBlockAnnotation parallelBlockAnnotation(Collection<String> privates) {
		ParallelBlockAnnotation pla = AnnotationFactory.eINSTANCE.createParallelBlockAnnotation();
		
		pla.getPrivates().addAll(privates);
		
		return pla;
	}
	public static BarrierAnnotation barrierAnnotation(boolean before) {
		return barrierAnnotation(before, 0);
	}
	public static BarrierAnnotation barrierAnnotation(boolean before, int type) {
		BarrierAnnotation ba = AnnotationFactory.eINSTANCE.createBarrierAnnotation();
		
		ba.setBefore(before);
		ba.setType(type);
		
		return ba;
	}
	
	public static VectorizationAnnotation vectorizationAnnotation(boolean ivdep){
		VectorizationAnnotation va = AnnotationFactory.eINSTANCE.createVectorizationAnnotation();
		
		va.setIvdep(ivdep);
		
		return va;
	}
	
	public static PolyhedralDomainAnnotation domainAnnotation(String domain) {
		PolyhedralDomainAnnotation pda = AnnotationFactory.eINSTANCE.createPolyhedralDomainAnnotation();
		
		pda.setDomain(domain);
		
		return pda;
	}
	/* PROTECTED REGION END */
}
