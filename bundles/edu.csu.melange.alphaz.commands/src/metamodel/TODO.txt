Scoping of Input instances would make things cleaner

IMPORTANT:
alphaz.command project now outputs code to alphaz and alphaz.mde projects, which are the two cores of the AlphaZ system
Please DO NOT commit to these two projects.

Key changes:
 * SpecializedOverloading : Some overloading is not a strict subset of the basic command,  and needs special operation.
                         e.g. converting affine functions given as string into affine function object.
 * userCommand attribute : used to flag if a command should be exposed to the end-user or not
 * Two root definitions for generating to two different target projects in JavaInterface.xpt
 * Types are now mapped directly with Java objects
 * Removed suffix

Remaining Tasks Overview:
1a. Complete the alphaz commands model (alphazCommands.commandif)
   Using the customized editor should make it easier than before. (5hrs)+(5hrs for completing description)
   complete = add all methods listed below and its overloadings
1b. With the complete model, test the JavaInterface generator. (2hrs)
2a. Complete the Script generator
   This involves generating two things,
     i)  generating Java classes that implement the calls to methods generated by JavaInterface generation (5hrs/7hrs)
     ii) generating plugin.xml so that generated classes are registered to the script engine (1hr)
2b. Test the Script generator with the complete model (5hrs)
3. Complete the Documentation generator
     this part is still open. What is a good output format for docs?
     multiple documentations can be generated without worrying about consistency

Detail:
1a. Add all commands listed below to the model. 
Skip descriptions in the first pass. AM (called TPMSpec before) and CodeGen are already complete, look at these as examples.
Refer to the bean shell scripts for inputs and overloadings of the unimplemented commands.
However, calculator will be significantly different from bean shell implementation. For those commands, inputs are given below.
Output for calculator commands be one of alphabetsFunctionAPrx, alphabetsPolyDomainAPrx, or Boolean
Except for commands in calculator, add 'ProgramProxy program' as the first input, which is not present in the bean shell scripts.

In the second pass, fill in the descriptions. Keep in mind this will be used as the text for documentation generated.
Use the comments in bean shell scripts to understand the command, but do not copy & paste the comments in bean shell.
Those comments in the bean shell were written by the developers, and it may not make good sense to the users.
By having you understand the command and re-writing in your own words, we hope that it becomes easier for the users to follow.
Of course, if you don't understand the commands, just ask whoever is the author (usually Tomofumi)

1b. Make sure that generated code will not have errors, after you solve all the imports by shift+ctrl+O
Once you generate and get the imports, put the imports into the protected region and re-generate. This should work fine.
Check all the commands and package names for miss spellings.

2a-i.
Generate a class for each command, where the class is 
edu.csu.melange.alphaz.command.scripts.ClassName of project edu.csu.melange.alphaz.command.scripts
where ClassName is command name with first character upper case. There is a method named toFirstUpper for this
e.g. alphaz.mde.CodeGen.writeC will be come edu.csu.melange.alphaz.command.scripts.WriteC
Here we assume two commands of the same name that are both exposed to the user will not exist in the model.
This can be added to the validity condition later.
We may change the naming later after seeing how it actually works in the scripting environment.

Inside each class there will be one constructor for each overloading and one the basic command.
In the constructor, call the corresponding static method in JavaInterface generated, and if the output is not void,
store the result in a member variable named result.
Then in the compute method, return the result or do nothing if output is void.
These classes can be generated fully automatic, but don't worry about the imports for now.
Use protected region so that imports won't have to be resolved every time the code is re-generated.
Once other part is complete, work on generating imports automatically as well. The classes used can be deduced from inputs and output.

2a-ii. Generate plugin.xml, similar to the one in alphaz.bindings project that registers all commands.
This should be straight forward after 2a-i.
Implement it inside CompilerScript.xpt, starting from its own root DEFINE
Use command name as the name of module, without changing the first character to upper case.


Unimplemented Commands:
alphaz.analysis.Farkas1D
alphaz.analysis.RDG

alphaz.transformation.CoB
alphaz.transformation.Cut
alphaz.transformation.SubstituteByDef
alphaz.transformation.AddLocal
alphaz.transformation.RemoveUnusedVariables
alphaz.transformation.Uniformization

alphaz.transformation.reduction.FactorOutFromReduction
alphaz.transformation.reduction.NormalizeReductions
alphaz.transformation.reduction.PermutationCaseReduce
alphaz.transformation.reduction.ReductionDecomposition
alphaz.transformation.reduction.SimplifyingReductions
alphaz.transformation.reduction.TransformReductionBody

////Calculator
//1 string input
alphaz.calc.readDomain
alphaz.calc.readFunction
//1 function
alphaz.calc.inverse
//1 function, 1 domain
alphaz.calc.inverseInContext
//2 functions
alphaz.calc.compose
alphaz.calc.join
//1 domain
alphaz.calc.isEmpty
//2 domains
alphaz.calc.union
alphaz.calc.intersection
//1 domain, 1 function
alphaz.calc.image
alphaz.calc.preimage
